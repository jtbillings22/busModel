<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>6 Bus Route Simulation (Colored Buses + Variable Speeds)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { height: 100vh; width: 100%; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([40.505, -74.445], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // --- Route coordinates ---
    const route = [
      [40.503363, -74.452133], // CASC
      [40.499489, -74.448194], // Yard
      [40.499029, -74.447710],
      [40.499788, -74.445206],
      [40.502674, -74.446683],
      [40.503922, -74.448940], // SAC
      [40.505642, -74.451873],
      [40.506522, -74.452113],
      [40.507348, -74.457383],
      [40.514056, -74.458417],
      [40.524959, -74.448367],
      [40.522846, -74.440951],
      [40.525078, -74.438596], // Plaza
      [40.525500, -74.438212],
      [40.524419, -74.436297],
      [40.523819, -74.436500], // LSC
      [40.523905, -74.435512],
      [40.522787, -74.432817],
      [40.519926, -74.433532], // Quads
      [40.518984, -74.434268],
      [40.525737, -74.450831],
      [40.525323, -74.454084],
      [40.526513, -74.454212],
      [40.522182, -74.450528],
      [40.514700, -74.457792],
      [40.507180, -74.457088],
      [40.505893, -74.452559],
      [40.505140, -74.453856],
      [40.503363, -74.452133], // CASC
    ];

    const stopIndices = [0, 1, 5, 12, 15, 18, 28];
    const stopNames = ["CASC", "Yard", "SAC", "Plaza", "LSC", "Quads", "CASC"];
    const longStopStops = [0, 15, 28]; // CASC & LSC

    // --- Draw route + stops ---
    const line = L.polyline(route, { color: 'blue', weight: 4 }).addTo(map);
    map.fitBounds(line.getBounds());
    stopIndices.forEach((idx, i) => {
      L.circleMarker(route[idx], { radius: 6, color: 'red', fillColor: 'red', fillOpacity: 0.8 })
        .bindPopup(stopNames[i])
        .addTo(map);
    });

    // --- Helper: distance ---
    function distance(a, b) {
      const R = 6371000;
      const lat1 = a[0]*Math.PI/180, lat2 = b[0]*Math.PI/180;
      const dLat = (b[0]-a[0])*Math.PI/180, dLon = (b[1]-a[1])*Math.PI/180;
      const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2*R*Math.atan2(Math.sqrt(h), Math.sqrt(1-h));
    }

    // --- Build route segments ---
    const segments = [];
    let totalDist = 0;
    for (let i = 0; i < route.length - 1; i++) {
      const d = distance(route[i], route[i+1]);
      segments.push({ start: route[i], end: route[i+1], dist: d, idx: i });
      totalDist += d;
    }

    // --- Speed zones ---
    function getSpeedMultiplier(segmentIdx) {
      // Faster between SAC (5) → Plaza (12) and Quads (18) → CASC (28)
      if (segmentIdx >= 5 && segmentIdx <= 12) return 2;
      if (segmentIdx >= 18 && segmentIdx <= 28) return 2;
      return 1.0;
    }

    // --- Settings ---
    const numBuses = 6;
    const baseSpeed = 200;
    const stopTime = 200;
    const longStopTime = 3000;
    const longStopProb = 0.2;
    const colors = ['red', 'blue', 'green', 'orange', 'purple', 'yellow'];

    // --- Create buses ---
    const buses = [];
    for (let i = 0; i < numBuses; i++) {
      const offset = (totalDist / numBuses) * i;
      const svg = encodeURIComponent(`
        <svg xmlns='http://www.w3.org/2000/svg' width='28' height='28'>
          <circle cx='14' cy='14' r='10' fill='${colors[i]}' stroke='black' stroke-width='2'/>
        </svg>
      `);
      const icon = L.icon({
        iconUrl: "data:image/svg+xml," + svg,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
      const marker = L.marker(route[0], { icon }).addTo(map);
      buses.push({
        marker,
        traveled: offset,
        paused: false,
        lastStopIndex: -1,
        lastTime: performance.now(),
        prevPos: route[0]
      });
    }

    // --- Stop detection helper ---
    function passedStop(prev, curr) {
      for (const idx of stopIndices) {
        const stop = route[idx];
        const d1 = distance(prev, stop);
        const d2 = distance(curr, stop);
        if (d1 > 15 && d2 < 15) return idx;
      }
      return -1;
    }

    // --- Animation loop ---
    function animate(time) {
      buses.forEach(bus => {
        const dt = (time - bus.lastTime) / 1000;
        bus.lastTime = time;

        if (!bus.paused) {
          let distRemaining = baseSpeed * dt;
          // Find segment and adjust by zone multiplier
          let distSoFar = 0;
          for (const s of segments) {
            if (bus.traveled <= distSoFar + s.dist) {
              const multiplier = getSpeedMultiplier(s.idx);
              bus.traveled += baseSpeed * multiplier * dt;
              if (bus.traveled > totalDist) bus.traveled -= totalDist;
              break;
            }
            distSoFar += s.dist;
          }
        }

        // Compute position
        let distSoFar = 0, lat, lng, segmentIdx = 0;
        for (const s of segments) {
          if (bus.traveled <= distSoFar + s.dist) {
            const progress = (bus.traveled - distSoFar) / s.dist;
            lat = s.start[0] + progress * (s.end[0] - s.start[0]);
            lng = s.start[1] + progress * (s.end[1] - s.start[1]);
            segmentIdx = s.idx;
            break;
          }
          distSoFar += s.dist;
        }

        const newPos = [lat, lng];
        bus.marker.setLatLng(newPos);

        const stopIdx = passedStop(bus.prevPos, newPos);
        if (stopIdx !== -1 && stopIdx !== bus.lastStopIndex && !bus.paused) {
          bus.paused = true;
          bus.lastStopIndex = stopIdx;

          let duration = stopTime;
          if (longStopStops.includes(stopIdx) && Math.random() < longStopProb) {
            duration = longStopTime;
          }
          setTimeout(() => { bus.paused = false; }, duration);
        }

        if (stopIdx === -1 && bus.lastStopIndex !== -1) bus.lastStopIndex = -1;
        bus.prevPos = newPos;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  </script>
</body>
</html>
